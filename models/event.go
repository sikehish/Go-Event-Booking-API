package models

import (
	"time"

	"github.com/sikehish/Go-Event-Booking-API/db"
)

type Event struct {
	ID          int64
	Name        string    `binding:"required"`
	Description string    `binding:"required"`
	Location    string    `binding:"required"`
	DateTime    time.Time `binding:"required"`
	UserID      int64
}

// var events = []Event{}

func (e *Event) Save() error {
	// events = append(events, e)
	query := `
	INSERT INTO events (name, description, location, date_time, user_id) VALUES (?, ?, ?, ?,?)`
	stmt, err := db.DB.Prepare(query) //Prepare creates a prepared statement for later queries or executions. Multiple queries or executions may be run concurrently from the returned statement.
	if err != nil {
		return err
	}

	defer stmt.Close() //eleases any resources associated with the prepared statement.

	result, err := stmt.Exec(e.Name, e.Description, e.Location, e.DateTime, e.UserID) //The order in which values have been mentioned in the query string has to be followed

	if err != nil {
		return err
	}

	id, err := result.LastInsertId() //LastInsertId returns the integer generated by the database in response to a command. Typically this will be from an "auto increment" column when inserting a new row.
	// fmt.Printf("%v %v", e.ID, id)
	e.ID = id
	return err
}

func GetAllEvents() ([]Event, error) {
	// return events
	query := "SELECT * FROM events"
	rows, err := db.DB.Query(query)
	if err != nil {
		return nil, err
	}

	defer rows.Close() // If Next is called and returns false and there are no further result sets, the Rows are closed automatically and it will suffice to check the result of Err.

	var events []Event

	for rows.Next() {
		var event Event
		err := rows.Scan(&event.ID, &event.Name, &event.Description, &event.Location, &event.DateTime, &event.UserID) //the order has to be the same as the order in which the columns were defined

		if err != nil {
			return nil, err
		}
		events = append(events, event)
	}
	return events, nil

}

func GetEventByID(id int64) (*Event, error) { //We return pointer to Event instead of Event because we want to return nil instead of empty Event struct(easier to check if the struct is empty)
	query := "SELECT * FROM events WHERE id = ?"
	row := db.DB.QueryRow(query, id)

	var event Event
	err := row.Scan(&event.ID, &event.Name, &event.Description, &event.Location, &event.DateTime, &event.UserID)

	if err != nil {
		return nil, err
	}

	return &event, nil
}

func (event Event) Update() error {
	query := `
	UPDATE events
	SET name=?, description=?,location=?, date_time=?
	WHERE id=? 
	`

	stmt, err := db.DB.Prepare(query)

	if err != nil {
		return err
	}

	defer stmt.Close()

	_, err = stmt.Exec(event.Name, event.Description, event.Location, event.DateTime, event.ID)

	return err
}

func (event Event) Delete() error {
	query := `DELETE FROM events WHERE id=?`
	stmt, err := db.DB.Prepare(query)

	if err != nil {
		return err
	}

	defer stmt.Close()

	_, err = stmt.Exec(event.ID)

	return err
}

func (event Event) Register(userId int64) error {
	query := `INSERT INTO registrations(event_id, user_id) VALUES(?, ?)`
	stmt, err := db.DB.Prepare(query)
	if err != nil {
		return err
	}
	defer stmt.Close()

	_, err = stmt.Exec(event.ID, userId)
	return err
}

func (event Event) Unregister(userId int64) error {
	query := `DELETE FROM registrations WHERE event_id=? AND user_id=?`
	stmt, err := db.DB.Prepare(query)
	if err != nil {
		return err
	}
	defer stmt.Close()

	_, err = stmt.Exec(event.ID, userId)
	return err
}

// ------------------------------------------
// DTO stands for Data Transfer Object. It is a design pattern used in software development to encapsulate the data that is being transferred between layers or components of a system. The main purpose of a DTO is to provide a way to exchange data between different parts of a program without exposing the internal details of the data structure.

type ParticipantDTO struct {
	ID    int64  `json:"id"`
	Email string `json:"email" binding:"required"`
}

// func MapToParticipantDTO(user User) ParticipantDTO {
// 	return ParticipantDTO{
// 		ID:    user.ID,
// 		Email: user.Email,
// 	}
// }

func GetEventParticipants(eventId int64) ([]ParticipantDTO, error) {

	query := `SELECT id, email FROM users WHERE id IN(SELECT user_id FROM registrations WHERE event_id=?)`

	rows, err := db.DB.Query(query, eventId)
	if err != nil {
		return nil, err
	}

	defer rows.Close() // If Next is called and returns false and there are no further result sets, the Rows are closed automatically and it will suffice to check the result of Err.

	var participants []ParticipantDTO

	for rows.Next() {
		var participant ParticipantDTO
		err := rows.Scan(&participant.ID, &participant.Email) //the order has to be the same as the order in which the columns were defined

		if err != nil {
			return nil, err
		}
		participants = append(participants, participant)
	}
	return participants, nil
}
